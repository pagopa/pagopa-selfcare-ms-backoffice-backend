package it.pagopa.selfcare.pagopa.backoffice.scheduler.function;


import feign.FeignException;
import it.pagopa.selfcare.pagopa.backoffice.client.ApiConfigClient;
import it.pagopa.selfcare.pagopa.backoffice.client.ApiConfigSelfcareIntegrationClient;
import it.pagopa.selfcare.pagopa.backoffice.entity.BrokerInstitutionEntity;
import it.pagopa.selfcare.pagopa.backoffice.entity.WrapperEntityOperations;
import it.pagopa.selfcare.pagopa.backoffice.model.connector.broker.Broker;
import it.pagopa.selfcare.pagopa.backoffice.model.connector.broker.Brokers;
import it.pagopa.selfcare.pagopa.backoffice.model.connector.creditorInstitution.BrokerCreditorInstitutionDetails;
import it.pagopa.selfcare.pagopa.backoffice.model.connector.creditorInstitution.CreditorInstitutionDetail;
import it.pagopa.selfcare.pagopa.backoffice.model.connector.station.StationDetails;
import it.pagopa.selfcare.pagopa.backoffice.model.connector.wrapper.WrapperType;
import it.pagopa.selfcare.pagopa.backoffice.repository.WrapperRepository;
import lombok.extern.slf4j.Slf4j;
import org.slf4j.MDC;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.cache.annotation.Cacheable;
import org.springframework.stereotype.Component;

import java.time.Instant;
import java.util.*;
import java.util.concurrent.CompletableFuture;
import java.util.stream.Collectors;
import java.util.stream.IntStream;

@Component
@Slf4j
public class AllPages {

    @Autowired
    private ApiConfigClient apiConfigClient;

    @Autowired
    private ApiConfigSelfcareIntegrationClient apiConfigSCIntClient;


    @Autowired
    private WrapperRepository wrapperRepository;


    @Value("${extraction.ibans.getBrokers.pageLimit}")
    private Integer getBrokersPageLimit;

    @Value("${extraction.ibans.getCIByBroker.pageLimit}")
    private Integer getCIByBrokerPageLimit;


    /**
     * @return the set of all brokers in pagoPA platform
     */
    @Cacheable(value = "getAllBrokers")
    public Set<String> getAllBrokers() {
        return executeParallelClientCalls(getBrokerECCallback, getNumberOfBrokerECPagesCallback,
                Brokers::getBrokerList, Broker::getBrokerCode,
                getBrokersPageLimit, null);
    }

    @Cacheable(value = "getCreditorInstitutionsAssociatedToBroker")
    public Set<BrokerInstitutionEntity> getCreditorInstitutionsAssociatedToBroker(String brokerCode) {
        Map<String, String> mdcContextMap = MDC.getCopyOfContextMap();
        int numberOfPages = getCreditorInstitutionsAssociatedToBrokerPages.search(1, 0, brokerCode);

        List<CompletableFuture<Set<BrokerInstitutionEntity>>> futures = new LinkedList<>();

        // create parallel calls
        CompletableFuture<Set<BrokerInstitutionEntity>> future = CompletableFuture.supplyAsync(() -> {
            if(mdcContextMap != null) {
                MDC.setContextMap(mdcContextMap);
            }
            return IntStream.rangeClosed(0, numberOfPages)
                    .parallel()
                    .mapToObj(page -> getCreditorInstitutionsAssociatedToBroker.search(getCIByBrokerPageLimit, page, brokerCode))
                    .flatMap(response -> response.getCreditorInstitutions().stream())
                    .map(elem -> convertCreditorInstitutionDetailToBrokerInstitutionEntity(elem))
                    .collect(Collectors.toSet());
        });
        futures.add(future);

        // join parallel calls
        return CompletableFuture.allOf(futures.toArray(new CompletableFuture[0]))
                .thenApply(e -> futures.stream()
                        .map(CompletableFuture::join)
                        .flatMap(Collection::stream)
                        .collect(Collectors.toSet()))
                .join();
    }


    /**
     * ...
     *
     * @param paginatedSearch
     * @param pageNumberSearch
     * @param getResultList
     * @param mapInRequiredClass
     * @param limit
     * @param filterCode
     * @param <M>                the main type retrieved from main search, i.e. the type that contains the list of results and the PageInfo detail
     * @param <N>                the type of the nested object retreived from main search, i.e. the type related to the list of results
     * @param <R>                the type of the final result list generated by the 'mapInRequiredClass' callback
     * @return the set of object in type 'R', mapped by <code>mapInRequiredClass</code> callback.
     */
    public <M, N, R> Set<R> executeParallelClientCalls(PaginatedSearch<M> paginatedSearch, NumberOfTotalPagesSearch pageNumberSearch,
                                                       GetResultList<M, N> getResultList, MapInRequiredClass<N, R> mapInRequiredClass,
                                                       int limit, String filterCode) {

        Map<String, String> mdcContextMap = MDC.getCopyOfContextMap();
        int numberOfPages = pageNumberSearch.search(1, 0, filterCode);

        List<CompletableFuture<Set<R>>> futures = new LinkedList<>();

        // create parallel calls
        CompletableFuture<Set<R>> future = CompletableFuture.supplyAsync(() -> {
            if(mdcContextMap != null) {
                MDC.setContextMap(mdcContextMap);
            }
            return IntStream.rangeClosed(0, numberOfPages)
                    .parallel()
                    .mapToObj(page -> paginatedSearch.search(limit, page, filterCode))
                    .flatMap(response -> getResultList.get(response).stream())
                    .map(mapInRequiredClass::map)
                    .collect(Collectors.toSet());
        });
        futures.add(future);

        // join parallel calls
        return CompletableFuture.allOf(futures.toArray(new CompletableFuture[0]))
                .thenApply(e -> futures.stream()
                        .map(CompletableFuture::join)
                        .flatMap(Collection::stream)
                        .collect(Collectors.toSet()))
                .join();
    }


    private final PaginatedSearch<Brokers> getBrokerECCallback = (int limit, int page, String code) ->
            apiConfigClient.getBrokersEC(limit, page, code, null, null, null);

    private final PaginatedSearch<BrokerCreditorInstitutionDetails> getCreditorInstitutionsAssociatedToBroker = (int limit, int page, String code) ->
            apiConfigSCIntClient.getCreditorInstitutionsAssociatedToBroker(limit, page, true, code);

    private final NumberOfTotalPagesSearch getCreditorInstitutionsAssociatedToBrokerPages = (int limit, int page, String code) -> {
        var response = apiConfigSCIntClient.getCreditorInstitutionsAssociatedToBroker(limit, page, true, code);
        return (int) Math.floor((double) response.getPageInfo().getTotalItems() / getBrokersPageLimit);
    };

    private final NumberOfTotalPagesSearch getNumberOfBrokerECPagesCallback = (int limit, int page, String code) -> {
        Brokers response = apiConfigClient.getBrokersEC(limit, page, null, null, null, null);
        return (int) Math.floor((double) response.getPageInfo().getTotalItems() / getBrokersPageLimit);
    };

    private BrokerInstitutionEntity convertCreditorInstitutionDetailToBrokerInstitutionEntity(CreditorInstitutionDetail ci) {
        Instant activationDate = null;
        var wrapper = wrapperRepository.findByIdAndType(ci.getStationCode(), WrapperType.STATION);
        if(wrapper.isPresent() && wrapper.get().getEntities() != null && wrapper.get().getEntities().get(0) != null) {
            StationDetails station = ((WrapperEntityOperations<StationDetails>) wrapper.get().getEntities().get(0)).getEntity();
            activationDate = station.getActivationDate();
        }

        return BrokerInstitutionEntity.builder()
                .applicationCode(ci.getApplicationCode())
                .broadcast(ci.getBroadcast())
                .cbillCode(ci.getCbillCode())
                .companyName(ci.getBusinessName())
                .administrativeCode(null)
                .taxCode(ci.getCreditorInstitutionCode())
                .intermediated(isIntermediated(ci))
                .brokerCompanyName(ci.getBrokerBusinessName())
                .brokerTaxCode(ci.getBrokerCode())
                .model(3)
                .auxDigit(toInt(ci))
                .segregationCode(ci.getSegregationCode())
                .applicationCode(ci.getApplicationCode())
                .cbillCode(ci.getCbillCode())
                .stationId(ci.getStationCode())
                .stationState(ci.getStationEnabled() ? "ENABLED" : "DISABLED")
                .activationDate(activationDate)
                .version(String.valueOf(ci.getStationVersion()))
                .broadcast(ci.getBroadcast())
                .pspPayment(ci.getPspPayment())
                .build();
    }

    private boolean isIntermediated(CreditorInstitutionDetail ci) {
        boolean intermediated;
        try {
            apiConfigClient.getBroker(ci.getStationCode());
            intermediated = true;
        } catch (FeignException.NotFound e) {
            intermediated = true;
        }
        return intermediated;
    }

    private static int toInt(CreditorInstitutionDetail ci) {
        return ci.getAuxDigit() != null ? Math.toIntExact(ci.getAuxDigit()) : 0;
    }
}
