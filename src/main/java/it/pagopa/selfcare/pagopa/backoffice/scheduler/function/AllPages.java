package it.pagopa.selfcare.pagopa.backoffice.scheduler.function;


import it.pagopa.selfcare.pagopa.backoffice.client.ApiConfigClient;
import it.pagopa.selfcare.pagopa.backoffice.model.connector.broker.Broker;
import it.pagopa.selfcare.pagopa.backoffice.model.connector.broker.Brokers;
import lombok.extern.slf4j.Slf4j;
import org.slf4j.MDC;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.cache.annotation.Cacheable;
import org.springframework.stereotype.Component;

import java.util.Collection;
import java.util.LinkedList;
import java.util.List;
import java.util.Map;
import java.util.Set;
import java.util.concurrent.CompletableFuture;
import java.util.stream.Collectors;
import java.util.stream.IntStream;

@Component
@Slf4j
public class AllPages {

    private ApiConfigClient apiConfigClient;

    private Integer getBrokersPageLimit;

    @Autowired
    public AllPages(
            ApiConfigClient apiConfigClient,
            @Value("${extraction.ibans.getBrokers.pageLimit}") Integer getBrokersPageLimit
    ) {
        this.apiConfigClient = apiConfigClient;
        this.getBrokersPageLimit = getBrokersPageLimit;
    }

    /**
     * @return the set of all brokers in pagoPA platform
     */
    @Cacheable(value = "getAllBrokers")
    public Set<String> getAllBrokers() {
        return executeParallelClientCalls(getBrokerECCallback, getNumberOfBrokerECPagesCallback,
                Brokers::getBrokerList, Broker::getBrokerCode,
                getBrokersPageLimit, null);
    }

    /**
     * ...
     *
     * @param paginatedSearch    function to invoke paginated search
     * @param pageNumberSearch   function to retrieve search page number
     * @param getResultList      function to extract result from paginated search
     * @param mapInRequiredClass mapping function
     * @param limit              chunk size for paginated search
     * @param filterCode         search filter parameter
     * @param <M>                the main type retrieved from main search, i.e. the type that contains the list of results and the PageInfo detail
     * @param <N>                the type of the nested object retreived from main search, i.e. the type related to the list of results
     * @param <R>                the type of the final result list generated by the 'mapInRequiredClass' callback
     * @return the set of object in type 'R', mapped by <code>mapInRequiredClass</code> callback.
     */
    public <M, N, R> Set<R> executeParallelClientCalls(
            PaginatedSearch<M> paginatedSearch, NumberOfTotalPagesSearch pageNumberSearch,
            GetResultList<M, N> getResultList, MapInRequiredClass<N, R> mapInRequiredClass,
            int limit, String filterCode
    ) {

        Map<String, String> mdcContextMap = MDC.getCopyOfContextMap();
        int numberOfPages = pageNumberSearch.search(1, 0, filterCode);

        List<CompletableFuture<Set<R>>> futures = new LinkedList<>();

        // create parallel calls
        CompletableFuture<Set<R>> future = CompletableFuture.supplyAsync(() -> {
            if (mdcContextMap != null) {
                MDC.setContextMap(mdcContextMap);
            }
            return IntStream.rangeClosed(0, numberOfPages)
                    .parallel()
                    .mapToObj(page -> paginatedSearch.search(limit, page, filterCode))
                    .flatMap(response -> getResultList.get(response).stream())
                    .map(mapInRequiredClass::map)
                    .collect(Collectors.toSet());
        });
        futures.add(future);

        // join parallel calls
        return CompletableFuture.allOf(futures.toArray(new CompletableFuture[0]))
                .thenApply(e -> futures.stream()
                        .map(CompletableFuture::join)
                        .flatMap(Collection::stream)
                        .collect(Collectors.toSet()))
                .join();
    }


    private final PaginatedSearch<Brokers> getBrokerECCallback = (int limit, int page, String code) ->
            apiConfigClient.getBrokersEC(limit, page, code, null, null, null);

    private final NumberOfTotalPagesSearch getNumberOfBrokerECPagesCallback = (int limit, int page, String code) -> {
        Brokers response = apiConfigClient.getBrokersEC(limit, page, null, null, null, null);
        return (int) Math.floor((double) response.getPageInfo().getTotalItems() / getBrokersPageLimit);
    };
}
